<html>
	<head>
		<title>Procedural Modeling</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
		<!-- <link rel="stylesheet" href="lib/codemirror/codemirror.css"> -->
		<!-- <script src="lib/codemirror/codemirror-compressed.js"></script> -->
		<script src="lib/jquery-2.1.3.min.js"></script>
		<script src="lib/three/three.min.js"></script>
		<script src="lib/three/OrbitControls.js"></script>
		<script src="lib/three/OBJLoader.js"></script>
		<script src="lib/dat.gui.min.js"></script>
		<script src="../webppl/compiled/webppl.min.js"></script>
		<script src="js/geometry.js"></script>
		<script src="js/modelstates.js"></script>
		<script src="js/grids.js"></script>
		<script src="js/intersection.js"></script>
	</head>
	<body>
<!-- 		<div>
			<textarea id="code">
				// This is a comment!
			</textarea>
		</div> -->
		<script>
			var scene, camera, renderer, materials, controls;
			var compiledCode, topK, _trampoline;
			var guistate, gui;
			var gui_sample = null, gui_score = null;
			var model = null;
			var targetmodel = null;
			var samps = null;
			var sampmodels = null;
			var voxparams =
			{
				// percentSameSigma: 0.02,
				// percentOutsideSigma: 0.02,
				percentSameSigma: 0.005,
				percentOutsideSigma: 0.005,
				size: 0.25,
				bounds: null,
				targetGrid: new Grids.BinaryGrid3()
			};

			function animate() 
			{
				requestAnimationFrame(animate);
				controls.update();
			}

			function render()
			{
				renderer.render(scene, camera);
			}

			function onWindowResize()
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
				render();
			}

			function webppl_compile(code)
			{
				compiledCode = webppl.compile("(function(){" + code + "})()");
				console.log("Code compiled.");
				webppl_generate();
			}

			function webppl_generate()
			{
				var t0;
				topK = function(store, erp)
				{
					_trampoline = null;

					var t1 = performance.now();
					console.log("Time: ", (t1-t0)/1000.0);

					samps = erp.samples;
					sampmodels = [];
					for (var i = 0; i < samps.length; i++) sampmodels.push(null);

					var bestidx = 0;
					var maxscore = -Infinity;
					var minscore = Infinity;
					for (var i = 0; i < samps.length; i++)
					{
						var entry = samps[i];
						if (entry.prob > maxscore)
						{
							maxscore = entry.prob;
							bestidx = i;
						}
						if (entry.prob > -Infinity)
							minscore = Math.min(entry.prob, minscore);
					}
					if (minscore === Infinity) minscore = -Infinity;

					if (gui_score !== null)
						gui.remove(gui_score);
					if (gui_sample !== null)
						gui.remove(gui_sample);
					guistate.score = maxscore;
					guistate.sampleIndex = bestidx;
					gui_score = gui.add(guistate, "score", minscore, maxscore);
					gui_sample = gui.add(guistate, "sampleIndex", 0, samps.length-1).step(1).name("sample #");
					gui_sample.onChange(select_sample);
					gui_sample.setValue(bestidx);   // Will invoke select_sample
					gui_sample.updateDisplay();
				}
				t0 = performance.now();
				eval(compiledCode);
			}

			function select_sample(i)
			{
				if (samps.length > 0)
				{
					var samp = samps[i];
					// Compute and cache THREE.Model objects for each sample
					if (sampmodels[i] === null)
					{
						var geo = samps[i].val.getCompleteGeometry().toThreeGeo();
						sampmodels[i] = new THREE.SceneUtils.createMultiMaterialObject(geo, materials);
					}
					scene.remove(scene.children[scene.children.length-1]);
					model = sampmodels[i];
					scene.add(model);
					gui_score.setValue(samps[i].prob);
					gui_score.updateDisplay();
					render();
				}
			}

			function toggle_target()
			{
				if (guistate.showTarget)
				{
					scene.remove(scene.children[scene.children.length-1]);
					scene.add(targetmodel);
				}
				else
				{
					scene.remove(scene.children[scene.children.length-1]);
					if (model !== null)
						scene.add(model);
					else
						scene.add(new THREE.Object3D());
				}
				render();
			}

			function init()
			{
				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 100 );
				camera.position.set(10, 10, 10);
				camera.lookAt(new THREE.Vector3(0, 0, 0));

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setClearColor(new THREE.Color(0.2, 0.2, 0.2), 1.0);
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				var amblight = new THREE.AmbientLight(new THREE.Color(.3, .3, .3).getHex());
				var dirlight = new THREE.DirectionalLight(0xffffff, 1.0);
				dirlight.position.set(-1, 1, 1);
				scene.add(amblight);
				scene.add(dirlight);

				// Add dummy object to the Scene, to maintain the invariant that the last child is always
				//    the object being displayed.
				scene.add(new THREE.Object3D());

				materials = [
					new THREE.MeshLambertMaterial({ color: new THREE.Color(.9, .9, .9).getHex(), shading: THREE.FlatShading, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1 }),
					new THREE.MeshBasicMaterial({ color: 0x000000, shading: THREE.FlatShading, wireframe: true, wireframeLinewidth: 2, transparent: true })
				];

				controls = new THREE.OrbitControls( camera );
				controls.damping = 0.2;
				controls.addEventListener( 'change', render );

				gui = new dat.GUI();
				guistate = 
				{
					generate: webppl_generate,
					showTarget: false,
					score: 0,
					sampleIndex: 0
				}
				gui.add(guistate, "generate");
				gui.add(guistate, "showTarget").name("show target").onChange(toggle_target);

				window.addEventListener( 'resize', onWindowResize, false );
				animate();

				// var editor = CodeMirror.fromTextArea(document.getElementById("code"),
				// {
				// 	lineNumbers: true,
				// 	matchBrackets: true,
				// 	autoCloseBrackets: true
				// });

				// ------------------------------------------------

				var loader = new THREE.OBJLoader();
				loader.load("targets/shipProxy2.obj", function(object)
				{
					// Returns an Object3D which has one Mesh as a child.
					// The mesh's geometry is a BufferGeometry.
					var bufgeo = object.children[0].geometry;
					targetmodel = new THREE.SceneUtils.createMultiMaterialObject(bufgeo, materials);
					var geom = new THREE.Geometry();
					geom.fromBufferGeometry(bufgeo);
					var mygeom = new Geo.Geometry();
					mygeom.fromThreeGeo(geom);
					voxparams.bounds = mygeom.getbbox().clone();
					voxparams.bounds.expandByScalar(0.1);
					voxparams.targetGrid.clearall();
					mygeom.voxelize(voxparams.targetGrid, voxparams.bounds, voxparams.size, true);
					console.log("Target grid ready.")

					$.get("programs/spaceship.wppl", webppl_compile);
				});

				// var box = Geo.Shapes.Box(0, 0, 0, 4, 4, 2);
				// var cyl = Geo.Shapes.Cylinder(0, 0, 0, 2, 8, 1, 1);
				// var m = new THREE.Matrix4();
				// m.makeRotationX(Math.PI/2);
				// cyl.transform(m);
				// m.makeTranslation(0, 0, 1);
				// cyl.transform(m);
				// console.log(box.intersects(cyl));
				// cyl.merge(box);
				// var obj = new THREE.SceneUtils.createMultiMaterialObject(cyl.toThreeGeo(), materials);
				// scene.add(obj);
				// render();

			}

			init();
			render();
		</script>
	</body>
</html>



