
// ----------------------------------------------------------------------------

var generate = function()
{
	return addBody(newState(), 0, -5, {type: null, xlen: 0, ylen: 0});
}

var addBody = function(state, i, rearz, prev)
{
	// Gen new body segment
	var rets = addBodySeg(state, rearz, prev);
	var xlen = rets.xlen;
	var ylen = rets.ylen;
	var zlen = rets.zlen;
	var bodyType = rets.type;
	var newstate1 = rets.state;
	var wingprob = wi(i+1, 0.5);
	// Gen wings?
	var newstate2 = flip(wingprob) ?
						addWings(newstate1, 0, 0.5*xlen, rearz+0.5, rearz+zlen-0.5)
						:
						newstate1;
	// Gen fin?
	var finprob = 0.7;
	var newstate3 = flip(finprob) ?
						addFin(newstate2, 0, 0.5*ylen, rearz, rearz+zlen, 0.6*xlen)
						:
						newstate2;
	// Continue generating?
	var nextprev = {type: bodyType, xlen: xlen, ylen: ylen};
	if (flip(wi(i, 0.4)))
		return addBody(newstate3, i+1, rearz+zlen, nextprev);
	else
	{	
		var addnose = flip(0.75);
		// TODO: Also have a box nose, like the old version?
		return addnose ?
			addCylinderBodySeg(newstate3, rearz+zlen, nextprev, true).state
			:
			newstate3;
	}
}

var wi = function(i, w) { return Math.exp(-w*i); }

var BodyType = { Box: 0, Cylinder: 1, Cluster: 2, N: 3 }
var addBodySeg = function(state, rearz, prev)
{	
	var type = randomInteger(BodyType.N);
	if (type == BodyType.Box)
		return addBoxBodySeg(state, rearz, prev)
	else if (type == BodyType.Cylinder)
		return addCylinderBodySeg(state, rearz, prev);
	else if (type == BodyType.Cluster)
		return addClusterBodySeg(state, rearz, prev);
}

var addBoxBodySeg = function(state, rearz, prev)
{
	// Must be bigger than the previous segment, if the previous
	//   segment was not a box (i.e. was a cylinder-type thing)
	var xl = uniformrel(1, 3);
	var yl = uniformrel(.5, 1) * xl;
	var xlen = (prev.type === BodyType.Box) ? xl : Math.max(xl, prev.xlen);
	var ylen = (prev.type === BodyType.Box) ? yl : Math.max(yl, prev.ylen);
	var zlen = uniformrel(2, 5);
	var geo = Geo.Shapes.Box(0, 0, rearz + 0.5*zlen, xlen, ylen, zlen);
	var newstate = addGeometry(state, geo);
	return { xlen: xlen, ylen: ylen, zlen: zlen, type: BodyType.Box, state: newstate };
}

var addCylinderBodySeg = function(state, rearz, prev, isnose)
{
	// Must be smaller than previous segment, if that was a box
	var limitrad = 0.5*Math.min(prev.xlen, prev.ylen);
	var minrad = (prev.type === BodyType.Box) ? 0.4*limitrad : 0.3;
	var maxrad = (prev.type === BodyType.Box) ? limitrad : 1.25;
	var radius = uniformrel(minrad, maxrad);
	var xlen = radius*2;
	var ylen = radius*2;
	var zlen = isnose ? uniformrel(1, 3) : uniformrel(2, 5);
	var geo = isnose ? BodyCylinder(rearz, zlen, radius, radius*uniformrel(.25, .75))
					 : BodyCylinder(rearz, zlen, radius);
	var newstate = addGeometry(state, geo);
	return { xlen: xlen, ylen: ylen, zlen: zlen, type: BodyType.Cylinder, state: newstate };
}

var addClusterBodySeg = function(state, rearz, prev, isnose)
{
	// Must be smaller than previous segment, if that was a box
	var limitrad = 0.25*Math.min(prev.xlen, prev.ylen);
	var minrad = (prev.type === BodyType.Box) ? 0.4*limitrad : 0.5*0.3;
	var maxrad = (prev.type === BodyType.Box) ? limitrad : 0.5*1.25;
	var radius = uniformrel(minrad, maxrad);
	var xlen = radius*4;
	var ylen = radius*4;
	var zlen = uniformrel(2, 5);
	var geo = BodyCluster(rearz, zlen, radius);
	var newstate = addGeometry(state, geo);
	return { xlen: xlen, ylen: ylen, zlen: zlen, type: BodyType.Cluster, state: newstate };
}

var addWings = function(state, i, xbase, zlo, zhi)
{
	var rets = addWingSeg(state, xbase, zlo, zhi);
	var xlen = rets.xlen;
	var ylen = rets.ylen;	
	var zlen = rets.zlen;
	var zbase = rets.zbase;
	var newstate = rets.state;
	if (flip(wi(i, 0.6)))
		return addWings(newstate, i+1, xbase+xlen, zbase-0.5*zlen, zbase+0.5*zlen);
	else
		return newstate;
}

var WingType = { Box: 0, Cylinder: 1, N: 2 }
var addWingSeg = function(state, xbase, zlo, zhi)
{
	var type = randomInteger(WingType.N);
	if (type == WingType.Box)
		return addBoxWingSeg(state, xbase, zlo, zhi);
	else if (type == WingType.Cylinder)
		return addCylinderWingSeg(state, xbase, zlo, zhi);
}

var addBoxWingSeg = function(state, xbase, zlo, zhi)
{
	var zbase = uniformrel(zlo, zhi);
	var xlen = uniformrel(0.25, 2.0);
	var ylen = uniformrel(0.25, 1.25);
	var zlen = uniformrel(0.5, 4.0);
	var geo = WingBoxes(xbase, zbase, xlen, ylen, zlen);
	var newstate = addGeometry(state, geo);
	var newstate2 = flip(0.5) ? addWingGuns(newstate, xbase, zbase, xlen, ylen, zlen)
							  : newstate;
	return { xlen: xlen, ylen: ylen, zlen: zlen, zbase: zbase, state: newstate2 }
}

var addWingGuns = function(state, xbase, zbase, xlen, ylen, zlen)
{
	var gunlen = uniformrel(1, 1.2)*zlen;
	var gunxbase = xbase + 0.5*xlen;
	var gunybase = 0.5*ylen;
	var geo = WingGuns(gunxbase, gunybase, zbase, gunlen);
	return addGeometry(state, geo);
}

var addCylinderWingSeg = function(state, xbase, zlo, zhi)
{
	var zbase = uniformrel(zlo, zhi);
	var radius = uniform(.15, .7);
	var xlen = 2*radius;
	var ylen = 2*radius;
	var zlen = uniformrel(1, 5);
	var geo = WingCylinders(xbase, zbase, zlen, radius);
	var newstate = addGeometry(state, geo);
	return { xlen: xlen, ylen: ylen, zlen: zlen, zbase: zbase, state: newstate }
}

var addFin = function(state, i, ybase, zlo, zhi, xmax)
{
	var xlen = uniformrel(0.5, 1.0) * xmax;
	var ylen = uniformrel(0.1, 0.5);
	var zlen = uniformrel(0.5, 1.0) * (zhi - zlo);
	var zbase = 0.5*(zlo + zhi);
	var geo = Geo.Shapes.Box(0, ybase + 0.5*ylen, zbase, xlen, ylen, zlen);
	var newstate = addGeometry(state, geo);
	if (flip(wi(i, 0.2)))
		return addFin(newstate, i+1, ybase+ylen, zbase-0.5*zlen, zbase+0.5*zlen, xlen);
	else
		return newstate;
}


// ----------------------------------------------------------------------------


var uniformrel = function(lo, hi)
{
	var u = uniform(0, 1);
	return (1-u)*lo + u*hi;
}


// ----------------------------------------------------------------------------


// Generating / adding to model states
var newState = function()
{
	// Assume availability of global 'voxparams'
	return ModelStates.VoxelizingModelState.create(voxparams);
}
var addGeometry = function(state, geo)
{
	var newstate = state.addGeometry(geo);
	// If the score isn't already -Infinity, insert a new
	//    heuristic factor
	if (state.score > -Infinity)
		factor(newstate.score - state.score);
	return newstate;
}


// ----------------------------------------------------------------------------


// Geometric primitives specific to this program

var N_CYLINDER = 8;

var mrot = Object.create(THREE.Matrix4.prototype);
THREE.Matrix4.apply(mrot);
mrot.makeRotationX(Math.PI/2);
var m1 = Object.create(THREE.Matrix4.prototype);
THREE.Matrix4.call(m1);
var m2 = Object.create(THREE.Matrix4.prototype);
THREE.Matrix4.call(m2);
var BodyCylinder = function(zbase, length, baseRadius, tipRadius)
{
	m1.makeTranslation(0, 0, 0.5*length+zbase);
	m2.makeTranslation(0, -0.5*length, 0);
	m1.multiply(mrot).multiply(m2);
	var cyl = Geo.Shapes.Cylinder(0, 0, 0, length, N_CYLINDER, baseRadius, tipRadius);
	cyl.transform(m1);
	return cyl;
}

var m3 = Object.create(THREE.Matrix4.prototype);
THREE.Matrix4.call(m3);
var m4 = Object.create(THREE.Matrix4.prototype);
THREE.Matrix4.call(m4);
var BodyCluster = function(zbase, length, radius)
{
	var cyl = Geo.Shapes.Cylinder(0, 0, 0, length, N_CYLINDER, radius);
	var geo = Object.create(Geo.Geometry.prototype);
	Geo.Geometry.call(geo);
	m1.makeTranslation(0, 0, 0.5*length+zbase);
	m2.makeTranslation(0, -0.5*length, 0);
	m1.multiply(mrot).multiply(m2);
	// 1
	m3.makeTranslation(-radius, 0, -radius);
	m4.copy(m1).multiply(m3);
	geo.mergeWithTransform(cyl, m4);
	// 2
	m3.makeTranslation(-radius, 0, radius);
	m4.copy(m1).multiply(m3);
	geo.mergeWithTransform(cyl, m4);
	// 3
	m3.makeTranslation(radius, 0, -radius);
	m4.copy(m1).multiply(m3);
	geo.mergeWithTransform(cyl, m4);
	// 4
	m3.makeTranslation(radius, 0, radius);
	m4.copy(m1).multiply(m3);
	geo.mergeWithTransform(cyl, m4);
	return geo;
}

var WingBoxes = function(xbase, zbase, xlen, ylen, zlen)
{
	// Left
	var wings = Geo.Shapes.Box(xbase+0.5*xlen, 0, zbase, xlen, ylen, zlen);
	// Right
	wings.addBox(-(xbase+0.5*xlen), 0, zbase, xlen, ylen, zlen);
	return wings;
}

var WingCylinders = function(xbase, zbase, length, radius)
{
	var cyl = Geo.Shapes.Cylinder(0, 0, 0, length, N_CYLINDER, radius);
	var geo = Object.create(Geo.Geometry.prototype);
	Geo.Geometry.call(geo);
	m1.makeTranslation(0, -.5*length, 0);
	m2.copy(mrot).multiply(m1);
	// Left
	m3.makeTranslation(-xbase - radius, 0, zbase).multiply(m2);
	geo.mergeWithTransform(cyl, m3);
	// Right
	m3.makeTranslation(xbase + radius, 0, zbase).multiply(m2);
	geo.mergeWithTransform(cyl, m3);
	return geo;
}

var gunRadius = .15;
var tipRadius = .03;
var tipLength = .4;
var WingGuns = function(xbase, ybase, zbase, length)
{
	var gunproto = Geo.Shapes.Cylinder(0, 0, 0, length, N_CYLINDER, gunRadius);
	gunproto.addCylinder(0, length, 0, tipLength, N_CYLINDER, gunRadius, tipRadius);
	var geo = Object.create(Geo.Geometry.prototype);
	Geo.Geometry.call(geo);
	m1.makeTranslation(0, -.5*length, 0);
	m2.copy(mrot).multiply(m1);
	// 1
	m3.makeTranslation(-xbase, -ybase-gunRadius, zbase).multiply(m2);
	geo.mergeWithTransform(gunproto, m3);
	// 2
	m3.makeTranslation(-xbase, ybase+gunRadius, zbase).multiply(m2);
	geo.mergeWithTransform(gunproto, m3);
	// 3
	m3.makeTranslation(xbase, -ybase-gunRadius, zbase).multiply(m2);
	geo.mergeWithTransform(gunproto, m3);
	// 4
	m3.makeTranslation(xbase, ybase+gunRadius, zbase).multiply(m2);
	geo.mergeWithTransform(gunproto, m3);
	return geo;
}


// ----------------------------------------------------------------------------


// var N = 1
var N = 1000
return MH(generate, N, false, true);




