
// Generating / adding to model states
var newState = function(geo) {
	// Assume availability of global 'voxparams'
	return ModelStates.Compositional.Voxelizing.create(voxparams, geo);
};

var uniformrel = function(lo, hi) {
	var u = uniform(0, 1);
	return (1-u)*lo + u*hi;
};


// ----------------------------------------------------------------------------

var tmp = Object.new(THREE.Vector3);
var branch = function(origradius, frame, i, depth, prev) {
	// Only generate stuff if it's not too small to matter
	if (frame.radius / origradius >= 0.1) {
		var uprot = gaussian(0, Math.PI / 12);
		var leftrot = gaussian(0, Math.PI / 12);
		var len = uniformrel(3, 5) * frame.radius;
		var endradius = uniformrel(0.7, 0.9) * frame.radius;

		// Figure out where to split the segment
		// (This is so the part we branch from is a pure conic section)
		var nextframe = tree.advanceFrame(frame, uprot, leftrot, len, endradius);
		var splitframe = tree.findSplitFrame(frame, nextframe);

		// Place geometry
		var leafState = newState(tree.treeSegment(prev, frame, splitframe, nextframe));

		// Recursively branch
		var branchState = (function() {
			if (flip(tree.branchProb(depth, i))) {
				// Theta mean/variance based on avg weighted by 'up-facing-ness'
				var thetaMuSigma = tree.estimateThetaDistrib(splitframe, nextframe);
				var theta = gaussian(thetaMuSigma[0], thetaMuSigma[1]);
				var maxbranchradius = tmp.copy(nextframe.center).sub(splitframe.center)
				                         .multiplyScalar(0.5).length();
				var branchradius = Math.min(uniformrel(0.9, 1) * nextframe.radius, maxbranchradius);
				var bframeAndPrev = tree.branchFrame(splitframe, nextframe, 0.5, theta, branchradius);
				var bframe = bframeAndPrev.frame;
				var bprev = bframeAndPrev.prev;
				return leafState.combine(
					branch(origradius, bframe, 0, depth + 1, bprev)
				);
			} else return leafState;
		})();

		// Keep generating same branch?
		// return flip(tree.continueProb(i))
		// 	?
		// 	branchState.combine(branch(origradius, nextframe, i + 1, depth, null))
		// 	:
		// 	branchState;
		if (flip(tree.continueProb(i))) {
			var recurse = branch(origradius, nextframe, i + 1, depth, null);
			display(recurse);
			return branchState.combine(recurse);
		} else {
			return branchState;
		}
	}
};


var generate = function() {
	var startframe = {
		center: Object.new(THREE.Vector3, 0, 0, 0),
		forward: Object.new(THREE.Vector3, 0, 1, 0),
		up: Object.new(THREE.Vector3, 0, 0, -1),
		radius: uniformrel(1.5, 2),
		v: 0
	};
	var model = branch(startframe.radius, startframe, 0, 0, null);
	factor(model.score);
	return model;
};


// ----------------------------------------------------------------------------


// var N = 1000;
var N = 1;
return MH(generate, N, false, true);


